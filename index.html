<!DOCTYPE html>
<html>
  <head>
    <title>Blog</title>
    <meta charset="UTF-8">
    <link href="./css/main.css" rel="stylesheet" />
    <link href="./fontawesome/css/brands.min.css" rel="stylesheet" />
    <link href="./fontawesome/css/fontawesome.min.css" rel="stylesheet" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <header class="header">
      <nav role="navigation">
        <div class="nav-list">
          <div class="nav-list-icons">
            <ul class="nav-list-buttons">
              <li>
                <a
                  href="https://www.facebook.com/"
                  class="fab fa-facebook fa-lg"
                >
                </a>
              </li>
              <li>
                <a href="#" class="fab fa-github fa-lg"> </a>
              </li>
              <li>
                <a
                  href="https://www.linkedin.com/"
                  class="fab fa-linkedin fa-lg"
                >
                </a>
              </li>
              <li>
                <a href="https://www.twitter.com" class="fab fa-twitter fa-lg">
                </a>
              </li>
            </ul>
          </div>
          <ul class="nav-list-buttons">
            <li>
              <a href="./index.html" class="button2 button">
                <span> Home </span>
              </a>
            </li>
            <li>
              <a href="#" class="button2 button">
                <span> About </span>
              </a>
            </li>
            <li>
              <a href="#" class="button2 button"> Subscribe </a>
            </li>
          </ul>
        </div>
      </nav>
    </header>
    <div class="container">
      <aside class="sidebar">
        <h1 class="blogs-heading">Blog posts</h1>
        <div class="blog-menu">
          <div id="post1">
            <h2 class="blog-title">What are Binary Trees.</h2>
            <div id="post1-image" class="post"></div>
            <a href="./blog.html" class="button1 button">Read More</a>
          </div>
          <div id ="post2">
            <h2 class="blog-title">Fun with Graphs ...</h2>
            <div id="post2-image" class="post"></div>
            <a href="./coming.html" class="button1 button">Read More</a>
          </div>
        </div>
      </aside>
      <main class="main">
        <div class="page-title">
          <h1 class="page-main-title">Groove with Algo-rhythms.</h1>
          <p class="page-subtitle">
            A blog that wll help you ace your next tech interviews.
          </p>
          <p class="page-subtitle">
            Source :
            <a
              href="https://scientificprogrammer.net/2020/06/21/why-studying-algorithms-will-enhance-your-programming-career/"
              >scientificprogrammer.net</a
            >
          </p>
          <!-- <img src="images/algorithms.jpeg" /> -->
        </div>

        <div class="page-grid">
          <div class="main-txt">
            <p>
              As someone who is interested in becoming a software developer, you
              have probably heard that it’s important to learn algorithms. Or
              maybe you have already started your programming career and haven’t
              yet encountered a situation where knowledge of algorithms would be
              beneficial to you. Either way, you might be wondering why would
              you need to study algorithms.
            </p>

            <p>
              This is precisely what I will address today. Studying algorithms
              is important, but the reasons why it’s important may not seem
              obvious. Today, I will show you what those reasons are.
            </p>

            <p>
              And let us start with dispelling a common misconception – that,
              allegedly, knowledge of algorithms is absolutely critical if you
              want to be a professional software developer.
            </p>

            <h2>Knowledge of algorithms isn’t always required</h2>

            <p>
              Software development consists of many specialist areas. And, just
              like there are many areas for which
              <a
                href="https://scientificprogrammer.net/2020/02/21/why-you-dont-need-maths-to-become-a-programmer/"
                >you aren’t required to learn maths</a
              >
              beyond school level basics, there are plenty of areas that don’t
              require you to know any algorithms at all.
            </p>

            <p>
              But despite this fact, I don’t want to give people a false
              impression and encourage aspiring software developers to be
              mediocre. Whether learning something specific is necessary or not,
              becoming a software developer requires hard work and dedication.
              You will still absolutely have to
              <a
                href="https://scientificprogrammer.net/2020/03/01/how-to-get-your-first-job-as-a-self-taught-programmer/"
                >study a lot</a
              >
              if you want to have any meaningful success in software development
              career.
            </p>

            <p>
              So here are some reason why algorithms aren’t specifically needed
              in many software development niches:
            </p>

            <h3>
              1. Most algorithms are already implemented by core libraries
            </h3>

            <p>
              If you are only working with
              <a href="https://www.bbc.co.uk/bitesize/guides/z4cck2p/revision/1"
                >high-level languages</a
              >, such as JavaScript, Python, C#, etc., most algorithms that you
              would typically be taught in a computer science class are already
              implemented by core libraries of the language. For example, if you
              want to sort your array, there will already be a method called
              <em>sort()</em>, or equivalent, available to you. If you want to
              search your collection for a specific value, there will also be a
              method that you can call. And all of these methods will take just
              a simple set of parameters and execute a well optimized version of
              the algorithm.
            </p>

            <p>
              You don’t even need to know the names of any algorithms. All
              you’ll need to know is that if you want to rearrange your
              collection or check if your collection contains a specific value,
              there is a specific method in the core language library to use.
              And with this, you are unlikely to ever be required to write any
              algorithm yourself from scratch.
            </p>

            <h3>
              2. Some niches don’t even have problems solvable by algorithms
            </h3>

            <p>
              Let’s take the role of front end developer as an example. If
              that’s your niche, then you will be required to know how to create
              really nice and engaging user interfaces. You will need to know
              how CSS,
              <a href="https://www.w3.org/TR/WD-DOM/introduction.html">DOM</a>
              and JavaScript interact with each other. You will need to know
              various tricks, such as animations. But you are less likely to
              encounter complex calculation problems that back-end developers
              are likely to encounter.
            </p>

            <p>
              Of course, certain types of UI would require complex calculations.
              Any UI with a graphical designer functionality would be a good
              example of this. But even in this case, you would be able to use
              in-built methods rather than implementing your own algorithms.
            </p>

            <p>
              Database specialist is another example of a niche where knowledge
              of algorithms wouldn’t be a critical requirement. You would need
              to have a good knowledge of how to build your data storage so it’s
              as well-optimized as possible. For example, knowledge of correct
              <a href="https://www.sqlservertutorial.net/sql-server-indexes/"
                >table indexes</a
              >
              usage is a must. You would also need to know how to write
              well-optimized queries.
            </p>

            <p>
              Well, those people who have built the engines for the database
              management systems absolutely needed to implement a whole range of
              classic sorting, searching and other types of algorithms for those
              queries to be executed in the most efficient way possible. But you
              don’t have to know those details if you are building databases and
              not database engines. You can perform your job reasonably well
              without having a detailed knowledge of what algorithms your
              database engine implements under the hood.
            </p>

            <p>
              So, unless you are working on programming languages, building
              computational engines from scratch, developing communication
              protocols or simply writing any low-level code that executes close
              to hardware, you probably won’t explicitly write a single
              algorithm that you have learned in your computer science class.
            </p>

            <hr class="wp-block-separator" />

            <p>
              Here is some personal
              <a
                href="https://scientificprogrammer.net/2019/08/14/anecdotal-evidence-is-often-the-best-evidence/"
                >anecdote</a
              >. As a self-taught developer, I haven’t explicitly learned a
              single algorithm until I was three years into my professional
              career. And I was able to get quite far in my career without
              knowing any.
            </p>

            <p>
              But don’t get me wrong. The fact that you don’t necessarily have
              to learn algorithms doesn’t mean that you shouldn’t. There are
              still good reasons why learning algorithms will significantly
              benefit you, even if you have chosen a niche that doesn’t
              specifically require you to know any. This is why I eventually
              started to study them and this is why you should too.
            </p>

            <h2>What is so useful about algorithms</h2>

            <p>
              Contrary to what many believe, the main purpose of studying
              algorithms is not to memorize their steps and their names.
              Studying algorithms teach you how to think.
            </p>

            <p>
              So no, you don’t necessarily need to remember how to do
              <a href="https://www.geeksforgeeks.org/bubble-sort/"
                >bubble sort</a
              >
              and
              <a href="https://www.geeksforgeeks.org/merge-sort/">merge sort</a
              >. But after spending a good amount of time practicing solving
              problems with algorithms, you will start to intuitively understand
              the fundamental principles behind them. This will allow you to
              solve a large variety of problems in an efficient manner, even
              though your solution will be bespoke and won’t fully adhere to any
              classic algorithms from a computer science class.
            </p>

            <p>
              The same applies to learning computational complexity of
              algorithms, the so-called
              <a
                href="https://www.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/big-o-notation"
                >Big-O notation</a
              >. You don’t merely need to memorize computational complexity for
              every classic algorithm types. You need to gain understanding of
              why a particular algorithm has a particular computational
              complexity, so when you are working on a bespoke solution to a
              specific problem, you will be able to determine how alternative
              solutions might vary in efficiency.
            </p>

            <p>
              In my career as a software developer, even though I never had to
              write any of the classic algorithms from scratch, I have
              encountered many situations where understanding how algorithms
              work has helped me to come up with an efficient solution.
            </p>

            <p>
              A good example of it was a problem that I needed to solve with
              real-time railway data. A the software I was working on would
              ingest information about upcoming trains from a third-party feed.
              One of the core components of this data was a collection of
              objects representing the stations that the train would pass along
              its journey. Each of this object would include information like
              station code, estimated arrival and departure times, scheduled
              arrival and departure times and some other station-specific data.
            </p>

            <p>
              The problem with this data was that sometimes stations were
              excluded from the collection. This applied to some, but not all,
              stations that the train moved through but didn’t call at. However,
              the system that I was building absolutely needed to know every
              station that the train passed through, along with the estimated
              time at which the train would pass each station.
            </p>

            <p>
              I solved this problem by applying
              <a
                href="https://www.geeksforgeeks.org/divide-and-conquer-algorithm-introduction/"
                >divide and conquer</a
              >
              principle that I have learned from studying algorithms. The
              collection of calling stations would be iteratively traversed from
              both ends. So would be the reference data containing all stations
              along a particular route. This way, any stations missing from the
              list of passing stations would be determined and inserted into the
              data. And, because the traversal is happening both ways, the time
              at which the train is expected to pass the station would be
              interpolated efficiently and with a reasonable accuracy.
            </p>

            <p>
              If I didn’t know any algorithms, I would still have come up with a
              solution. But my solution would probably not be as efficient.
              Perhaps, it would even be an acceptable solution if the system
              would have been expected to only deal with small volumes of data.
              However, since the system was being built to handle large volumes
              of real-time train data, any brute-force type of solution would
              not have been efficient enough to deal with it.
            </p>

            <p>
              So, the take-away is, once you start working on
              <a
                href="https://scientificprogrammer.net/2019/08/18/how-big-data-web-applications-are-built/"
                >large scalable systems</a
              >, you will almost not be able to do your job as a programmer if
              you have zero comprehensions of algorithms.
            </p>

            <h2>Big tech would always asses your knowledge of algorithms</h2>

            <p>
              As well as teaching you how to think and giving you tools to solve
              your own bespoke problems in the most efficient way possible,
              algorithms are the only way to get employed by large tech
              companies, such as Amazon, Google, Microsoft and Uber. Every
              single one of these companies assesses your knowledge of
              algorithms during the recruitment process.
            </p>

            <p>
              And the reason for it is simple. When big tech companies hire a
              developer, they often wouldn’t look to place the developer in a
              specific role. The candidate would usually be expected to be able
              to fit into any of a relatively wide range of roles. And in some
              of them, the developers are guaranteed to encounter problems where
              only algorithmic solution would be suitable.
            </p>

            <p>
              But not all of these companies would want to know if you can tell
              the difference between bubble sort and merge sort. Amazon, for
              example, will give you some bespoke problems to solve during the
              interview. Those are precisely the kind of problems I’ve
              previously mentioned. You can’t solve them by just applying any
              standard classic algorithm, but you would require to use the
              fundamental principles of those to develop your own bespoke
              algorithms.
            </p>

            <p>
              So, it doesn’t matter if you know many algorithms by name. Even if
              you forgot the proper name for, let’s say, binary search, you
              would still have a good chance of passing Amazon interview, as
              long as you’ve had a reasonable amount of practice with
              algorithms.
            </p>

            <p>
              Basically, they don’t care how much academic knowledge you have.
              All they care about is whether you can solve complex problems
              efficiently.
            </p>

            <p>
              Sadly, not all companies implement the same enlightened selection
              process as Amazon does. Some do indeed test your academic
              knowledge of algorithms. So, even if you are smart, there are
              companies that you can fail an interview at because there is a
              specific algorithm that you have either forgotten or never knew in
              the first place. This is known as
              <a
                href="https://techbeacon.com/app-dev-testing/developer-shortage-or-time-rethink-technical-interview"
                >algorithm lottery</a
              >.
            </p>

            <p>
              Usually, algorithm lottery type of selection is only done by
              smaller companies. Unlike Amazon, they don’t have resources to
              design a recruitment process that assesses candidate’s skills as
              objectively as possible. All they know that Amazon and Google ask
              about algorithms, so it’s just assumed that this is what needs to
              be done.
            </p>

            <p>
              However, while most big tech companies asses knowledge of
              algorithms in a meaningful way, the companies that implement an
              arbitrary algorithm lottery are shooting themselves in a foot. You
              can often hear stories of
              <a href="https://daedtech.com/hiring-is-broken/"
                >exceptional candidates</a
              >
              who got rejected simply because they got unlucky by being asked to
              describe an algorithm they don’t know. Likewise, plenty of
              otherwise horrible developers pass through these filters just
              because they happen to remember the specific algorithms they’ve
              been asked about during the interview.
            </p>

            <h2>Wrapping up</h2>

            <p>
              So, you can now see that, while you can have a career in software
              development without explicitly studying algorithms, choosing to
              study them makes you much more effective in your job. And, if you
              want to have any chance at all of breaking into big tech, you
              absolutely must make yourself familiar with algorithms.
            </p>

            <p>
              The most important thing about studying algorithms is not merely
              memorising them, but getting to understand the principles behind
              them. And to do so, you have to spend your time practicing
              algorithms to solve real problems instead of just reading about
              the algorithms.
            </p>

            <p>
              And there are many good ways you can practice applying algorithmic
              solutions to problems. For example, you can register on
              <a href="https://marketing.hackerrank.com/">HackerRank</a> or
              <a href="https://www.topcoder.com/">Topcoder</a>. But my personal
              favorite way is
              <a href="https://www.codingame.com/home">CodinGame</a>. I’ve
              <a
                href="https://scientificprogrammer.net/2019/08/18/proven-way-to-make-programming-fun/"
                >previously explained</a
              >
              what I love so much about it.
            </p>

            <p>Good luck and happy hacking!</p>
          </div>
        </div>
      </main>
    </div>
    <footer class="footer">
      <p>©Copyright 2021 Groove with Algo-rhythms.</p>
    </footer>
  </body>
</html>
